name: deploy-ztp-relocatable
on:
  workflow_dispatch:
    inputs:
      KUBECONFIG:
        description: 'Absolute path to KUBECONFIG file?'
        required: true
      SPOKES_FILE:
        description: 'Absolute path to the Spokes YAML file?'
        required: true
      RUNNER:
        description: 'GitHub Action Runner Tag'
        required: true


env:
  KUBECONFIG: ${{github.event.inputs.KUBECONFIG}}
  SPOKES_FILE: ${{github.event.inputs.SPOKES_FILE}}
  OC_OCP_VERSION: '4.9'
  OC_OCP_TAG: '4.9.0-x86_64'
  OC_RHCOS_RELEASE: '49.84.202110081407-0'  # TODO automate it to get it automated using binary
  OC_ACM_VERSION: '2.4'
  DEPLOY_ACM_DIR: deploy-acm
  DEPLOY_REGISTRY_DIR: deploy-disconnected-registry
  DEPLOY_HTTPD_SERVER_DIR: deploy-httpd-server
  DEPLOY_HUB_CONFIGS_DIR: deploy-hub-configs
  DEPLOY_SPOKES_DIR: deploy-spoke
  SHARED_DIR: shared-utils


jobs:
  pre-flight:
    continue-on-error: true
    runs-on: ${{github.event.inputs.RUNNER}}   #tag with your runner tag
    steps:
      - uses: actions/checkout@v2 # create a checkout (pull repository) in the runner working_dir (usually _work)
      - run: git pull origin ${GITHUB_REF##*/}

      - name: Verification
        run: |
          export WORKDIR=${GITHUB_WORKSPACE}
          cd ${{env.SHARED_DIR}}
          ./verify_preflight.sh
      #TODO create the verify step if hub exist just to start from spoke step
      #- name: verify-if-hub-exists
      #  run: |
      #    cd ${{env.SHARED_DIR}}
      #    ./verify_if_hub_exists.sh

  deploy-httpd-server:
    needs: pre-flight          # run in parallel with the other jobs
    runs-on: ${{github.event.inputs.RUNNER}}
    #TODO if env after verify-if-hub-exists is true then run the following steps
    steps:
      - name: Deploy Internal HTTPD Server
        run: |
          export WORKDIR=${GITHUB_WORKSPACE}
          cd ${{env.DEPLOY_HTTPD_SERVER_DIR}}
          ./deploy.sh

  deploy-acm:
    needs: pre-flight          # run in parallel with the other jobs
    runs-on: ${{github.event.inputs.RUNNER}}
    steps:
      - name: Deploy RHACM with AI
        run: |
          export WORKDIR=${GITHUB_WORKSPACE}
          cd ${{env.DEPLOY_ACM_DIR}}
          ./deploy.sh

  deploy-disconnected-registry:
    needs: deploy-acm         # run in parallel with the other jobs
    runs-on: ${{github.event.inputs.RUNNER}}
    steps:
      - name: Deploy Internal Disconnected Registry
        run: |
          export WORKDIR=${GITHUB_WORKSPACE}
          cd ${{env.DEPLOY_REGISTRY_DIR}}
          ./deploy.sh hub
          ./ocp-sync.sh hub
    #      ./olm-sync.sh hub


  deploy-hub-config:
    needs: [deploy-acm, deploy-disconnected-registry, deploy-httpd-server]       # run in parallel with the other jobs
    runs-on: ${{github.event.inputs.RUNNER}}
    steps:
      - name: Deploy hub configuration
        run: |
          export WORKDIR=${GITHUB_WORKSPACE}
          cd ${{env.DEPLOY_HUB_CONFIGS_DIR}}
          ./deploy.sh

  deploy-spokes:
    needs: deploy-hub-config
    runs-on: ${{github.event.inputs.RUNNER}}
    steps:
      - name: Deploy Spokes
        run: |
          export WORKDIR=${GITHUB_WORKSPACE}
          cd ${{env.DEPLOY_SPOKES_DIR}}
          ./render_spokes.sh; sleep 3
          ./deploy.sh

  extract-spokes-list:
    needs: deploy-spokes
    runs-on: ${{github.event.inputs.RUNNER}}
    outputs:
      services: ${{ steps.spokeslist.outputs.services }}
    steps:
      - name: Extract list of Spokes
        id: spokeslist
        run: |
          echo "::set-output name=services::$(cat ${{github.event.inputs.SPOKES_FILE}} | yq e '.spokes.[] | keys | join(",")' - | jq -Rsc '. / "\n" - [""]')"

  verify-installation:
    needs: extract-spokes-list
    runs-on: ${{github.event.inputs.RUNNER}}
    continue-on-error: true
    strategy:
      matrix:
        service: ${{ fromJSON(needs.extract-spokes-list.outputs.services) }}
    steps:
      - name: ${{ matrix.service }}
        run: |
          export WORKDIR=${GITHUB_WORKSPACE}
          SPOKE=${{ matrix.service }}
          cd ${{env.DEPLOY_SPOKES_DIR}}
          ./wait_for_spoke.sh $SPOKE
