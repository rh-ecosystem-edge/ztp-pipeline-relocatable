/*
Copyright 2023 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
*/

package internal

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"sort"

	"github.com/cenkalti/backoff/v4"
	"github.com/go-logr/logr"
	"golang.org/x/exp/maps"
	"golang.org/x/exp/slices"
	"gopkg.in/yaml.v3"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	apiwatch "k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/util/retry"
	clnt "sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/rh-ecosystem-edge/ztp-pipeline-relocatable/ztp/internal/jq"
	"github.com/rh-ecosystem-edge/ztp-pipeline-relocatable/ztp/internal/logging"
	"github.com/rh-ecosystem-edge/ztp-pipeline-relocatable/ztp/internal/templating"
)

// ApplierBuilder contains the data and logic needed to create an object that knows how create
// Kubernetes API objects from templates. Don't create instances of this type directly, use the
// NewApplier function instead.
type ApplierBuilder struct {
	logger    logr.Logger
	client    clnt.WithWatch
	labels    map[string]string
	fsys      fs.FS
	root      string
	dirs      []string
	listeners []func(*ApplierEvent)
}

// Applier knows how to create Kubernetes API objects from templates. Don't create instances of
// this type directly, use the NewApplier function instead.
type Applier struct {
	logger    logr.Logger
	client    clnt.WithWatch
	labels    map[string]string
	jq        *jq.Tool
	engine    *templating.Engine
	templates []string
	listeners []func(*ApplierEvent)
}

// ApplierEventType defines the possible types of events.
type ApplierEventType string

const (
	// ApplierObjectCreated indicates that an object didn't exist and has been created.
	ApplierObjectCreated ApplierEventType = "ObjectCreated"

	// ApplierObjectExist indicates that an object already existed and therefore it hasn't been
	// created.
	ApplierObjectExist ApplierEventType = "ObjectExists"

	// ApplierCreateError indicates that an error occurred while trying to create an object.
	ApplierCreateError ApplierEventType = "CreateError"

	// ApplierStatusUpdated indicates that the status of an object has been updated.
	ApplierStatusUpdated ApplierEventType = "StatusUpdated"

	// ApplierStatusError indicates that an error occurred while trying to update the status of
	// an object.
	ApplierStatusError ApplierEventType = "StatusError"

	// ApplierObjectDeleted indicates that an object was deleted.
	ApplierObjectDeleted ApplierEventType = "ObjectDeleted"

	// ApplierDeleteError indicates that an error occurred while tring to delete an object.
	ApplierDeleteError ApplierEventType = "DeleteError"

	// ApplierObjectNotExist indicates that an object doesn't exist.
	ApplierObjectNotExist ApplierEventType = "ObjectNotExist"

	// ApplierWaitingCRD indicates that the applier is waiting for a custom resource definition
	// to exist before trying to create an object.
	ApplierWaitingCRD ApplierEventType = "WaitingCRD"

	// ApplierWaitingDisappear indicates that the applier is waiting for an object to completely
	// disappear before deleting the namespace.
	ApplierWaitingDisappear ApplierEventType = "WaitingDisappear"
)

// ApplierEvents represents an event generated by the applier to inform of the progress of its work.
type ApplierEvent struct {
	Type   ApplierEventType
	Object *unstructured.Unstructured
	Error  error
}

// NewApplier creates a builder that can then be used to create an object that knows how create
// Kubernetes API objects from templates.
func NewApplier() *ApplierBuilder {
	return &ApplierBuilder{}
}

// SetLogger sets the logger that the renderer will use to write log messages. This is mandatory.
func (b *ApplierBuilder) SetLogger(value logr.Logger) *ApplierBuilder {
	b.logger = value
	return b
}

// SetFS sets the file system containing the templates. This is mandatory.
func (b *ApplierBuilder) SetFS(value fs.FS) *ApplierBuilder {
	b.fsys = value
	return b
}

// SetRoot sets the root directory of the templates file system. Directories specified with the
// AddDir method are relative to this. This is optional.
func (b *ApplierBuilder) SetRoot(value string) *ApplierBuilder {
	b.root = value
	return b
}

// SetDir sets a directory within the templates filesystem root that contains templates for the
// Kubernetes API objects. This is optional. If no directory is specified then all the templates in
// the filesystem will be used. Note that this removes all previously configured directories, use
// AddDir if you want to preserve them.
func (b *ApplierBuilder) SetDir(value string) *ApplierBuilder {
	b.dirs = []string{value}
	return b
}

// AddDir adds a directory within the templates filesystem root that contains templates for the
// Kubernetes API objects. This is optional. If no directory is specified then all the templates in
// the filesystem will be used.
func (b *ApplierBuilder) AddDir(value string) *ApplierBuilder {
	b.dirs = append(b.dirs, value)
	return b
}

// SetDirs sets a set of directories within the templates filesystem root that contain templates for
// the Kubernetes API objects. This is optional. If no directory is specified then all the templates
// in the filesystem will be used. Note that this removes all previously configured directories, use
// AddDirs if you want to preserve them.
func (b *ApplierBuilder) SetDirs(values ...string) *ApplierBuilder {
	b.dirs = slices.Clone(values)
	return b
}

// AddDirs adds a set of directories within the templates filesystem root that contain templates for
// the Kubernetes API objects. This is optional. If no directory is specified then all the templates
// in the filesystem will be used.
func (b *ApplierBuilder) AddDirs(values ...string) *ApplierBuilder {
	b.dirs = append(b.dirs, values...)
	return b
}

// SetClient sets the Kubernetes API client that the applier will use to create the objects.
func (b *ApplierBuilder) SetClient(value clnt.WithWatch) *ApplierBuilder {
	b.client = value
	return b
}

// AddLabel adds a label that will be added to all the objects created. This is optional.
func (b *ApplierBuilder) AddLabel(name, value string) *ApplierBuilder {
	if b.labels == nil {
		b.labels = map[string]string{}
	}
	b.labels[name] = value
	return b
}

// AddLabels adds a the collection of labels that will be added to all the objects created. This is
// ooptional.
func (b *ApplierBuilder) AddLabels(values map[string]string) *ApplierBuilder {
	if b.labels == nil {
		b.labels = map[string]string{}
	}
	maps.Copy(b.labels, values)
	return b
}

// SetListener sets a function that will be called when an event is generated. This is optional.
// Note that this removes any previously added listener. If you want to preserve them use the
// AddListener function.
func (b *ApplierBuilder) SetListener(value func(*ApplierEvent)) *ApplierBuilder {
	b.listeners = []func(*ApplierEvent){value}
	return b
}

// AddListener adds a function that will be called when an event is generated. This is optional.
func (b *ApplierBuilder) AddListener(value func(*ApplierEvent)) *ApplierBuilder {
	b.listeners = append(b.listeners, value)
	return b
}

// Build uses the data stored in the builder to create a new applier.
func (b *ApplierBuilder) Build() (result *Applier, err error) {
	// Check parameters:
	if b.logger.GetSink() == nil {
		err = errors.New("logger is mandatory")
		return
	}
	if b.client == nil {
		err = errors.New("client is mandatory")
		return
	}
	if b.fsys == nil {
		err = errors.New("template filesystem is mandatory")
		return
	}

	// Create the jq tool:
	jq, err := jq.NewTool().
		SetLogger(b.logger).
		Build()
	if err != nil {
		err = fmt.Errorf("failed to create jq tool: %v", err)
		return
	}

	// Create the filesystem:
	fsys := b.fsys
	if b.root != "" {
		fsys, err = fs.Sub(b.fsys, b.root)
		if err != nil {
			return
		}
	}

	// Create the templating engine:
	engine, err := b.createEngine(fsys)
	if err != nil {
		err = fmt.Errorf("failed to create templating engine: %v", err)
		return
	}
	templates, err := b.findTemplates(fsys)
	if err != nil {
		err = fmt.Errorf("failed to find templates: %v", err)
		return
	}

	// Create and populate the object:
	result = &Applier{
		logger:    b.logger,
		client:    b.client,
		labels:    maps.Clone(b.labels),
		jq:        jq,
		engine:    engine,
		templates: templates,
		listeners: slices.Clone(b.listeners),
	}
	return
}

func (b *ApplierBuilder) createEngine(fsys fs.FS) (result *templating.Engine, err error) {
	result, err = templating.NewEngine().
		SetLogger(b.logger).
		SetFS(fsys).
		Build()
	return
}

func (b *ApplierBuilder) findTemplates(fsys fs.FS) (results []string, err error) {
	var templates []string
	dirs := b.dirs
	if len(dirs) == 0 {
		dirs = []string{"."}
	}
	for _, dir := range dirs {
		err = fs.WalkDir(fsys, dir, func(path string, d fs.DirEntry, err error) error {
			if err != nil {
				return err
			}
			if !d.Type().IsRegular() {
				return nil
			}
			templates = append(templates, path)
			return nil
		})
		if err != nil {
			return
		}
	}
	results = templates
	return
}

// Apply generates the objects passing the given data to the templates and then creates them.
func (a *Applier) Apply(ctx context.Context, data any) error {
	objects, err := a.Render(ctx, data)
	if err != nil {
		return err
	}
	return a.applyObjects(ctx, objects)
}

// ApplyObjects creates the given objects.
func (a *Applier) ApplyObjects(ctx context.Context, objects []*unstructured.Unstructured) error {
	// Namespaces and custom resource definitions need to be created first as other objects will
	// depend on them, so first we need to classify the rendered objects.
	namespaces, crds, others := a.classifyObjects(objects)

	// Create the namespaces:
	err := a.applyNamespaces(ctx, namespaces)
	if err != nil {
		return err
	}

	// Create the custom resource definitions:
	err = a.applyCRDs(ctx, crds)
	if err != nil {
		return err
	}

	// Create the rest of the objects:
	err = a.applyObjects(ctx, others)
	if err != nil {
		return err
	}

	return nil
}

// Delete generates the objects passing the given data to the templates and then deletes them.
func (a *Applier) Delete(ctx context.Context, data any) error {
	objects, err := a.Render(ctx, data)
	if err != nil {
		return err
	}
	return a.DeleteObjects(ctx, objects)
}

// DeleteObjects deletes the given objects.
func (a *Applier) DeleteObjects(ctx context.Context, objects []*unstructured.Unstructured) error {
	// Templates are usually in a logical creation order and we want to use the reverse order
	// for deletion:
	for i, j := 0, len(objects)-1; i < j; i, j = i+1, j-1 {
		objects[i], objects[j] = objects[j], objects[i]
	}

	// Namespaces can be deleted only when they are empty because the process to delete some of
	// the objects may need to create new temporary objects inside the namespace, and that fails
	// if the namespaces is marked for deletion. So we neeed to classify the object before
	// starting.
	namespaces, crds, others := a.classifyObjects(objects)

	// Delete the regular objects:
	err := a.deleteObjects(ctx, others)
	if err != nil {
		return err
	}

	// Delete the namespaces. Note that we need to pass the namespaces and the regular objects
	// because this will need to wait for those objects to be completely deleted.
	err = a.deleteNamespaces(ctx, namespaces, others)
	if err != nil {
		return err
	}

	// Delete the custom resource definitions:
	err = a.deleteCRDs(ctx, crds)
	if err != nil {
		return err
	}

	return nil
}

// Render generates the objects passing the given data to the templates, but doesn't actually create
// them.
func (a *Applier) Render(ctx context.Context, data any) (results []*unstructured.Unstructured,
	err error) {
	for _, template := range a.templates {
		var objects []*unstructured.Unstructured
		objects, err = a.renderObjects(ctx, data, template)
		if err != nil {
			return
		}
		results = append(results, objects...)
	}
	return
}

func (a *Applier) classifyObjects(objects []*unstructured.Unstructured) (namespaces, crds,
	others []*unstructured.Unstructured) {
	for _, object := range objects {
		switch {
		case a.isNamespace(object):
			namespaces = append(namespaces, object)
		case a.isCRD(object):
			crds = append(crds, object)
		default:
			others = append(others, object)
		}
	}
	return
}

func (a *Applier) isNamespace(object *unstructured.Unstructured) bool {
	gvk := object.GroupVersionKind()
	matchesGroup := gvk.Group == NamespaceGVK.Group
	matchesKind := gvk.Kind == NamespaceGVK.Kind
	return matchesGroup && matchesKind
}

func (a *Applier) isCRD(object *unstructured.Unstructured) bool {
	gvk := object.GroupVersionKind()
	matchesGroup := gvk.Group == CustomResourceDefinitionGVK.Group
	matchesKind := gvk.Kind == CustomResourceDefinitionGVK.Kind
	return matchesGroup && matchesKind
}

func (a *Applier) applyNamespaces(ctx context.Context,
	namespaces []*unstructured.Unstructured) error {
	return a.applyObjects(ctx, namespaces)
}

func (a *Applier) applyCRDs(ctx context.Context, crds []*unstructured.Unstructured) error {
	// Some CRD templates may have status, but we don't want to apply that:
	for _, crd := range crds {
		delete(crd.Object, "status")
	}

	// Create the objects:
	err := a.applyObjects(ctx, crds)
	if err != nil {
		return err
	}

	// Wait till all the CRDs have been established, as otherwise creating objects of the
	// corresponding kind will fail:
	if len(crds) > 0 {
		gvks := make([]schema.GroupVersionKind, len(crds))
		for i, crd := range crds {
			gvks[i] = crd.GroupVersionKind()
		}
		err = a.waitCRDs(ctx, gvks...)
		if err != nil {
			return err
		}
	}

	return nil
}

func (a *Applier) waitCRDs(ctx context.Context, gvks ...schema.GroupVersionKind) error {
	pending := map[schema.GroupVersionKind]bool{}
	for _, gvk := range gvks {
		pending[gvk] = true
	}
	list := &unstructured.UnstructuredList{}
	list.SetGroupVersionKind(CustomResourceDefinitionGVK)
	watch, err := a.client.Watch(ctx, list)
	if err != nil {
		return err
	}
	defer watch.Stop()
	for event := range watch.ResultChan() {
		object, ok := event.Object.(*unstructured.Unstructured)
		if !ok {
			continue
		}
		var gvks []schema.GroupVersionKind
		err = a.jq.Query(
			`.spec | [{
				"Group": .group,
				"Version": .versions[].name,
				"Kind": .names.kind
			}]`,
			object.Object, &gvks,
		)
		if err != nil {
			return err
		}
		var established string
		err = a.jq.Query(
			`.status.conditions[]? | select(.type == "Established") | .status`,
			object.Object, &established,
		)
		if err != nil {
			return err
		}
		if established != "True" {
			continue
		}
		for _, gvk := range gvks {
			delete(pending, gvk)
		}
		if len(pending) == 0 {
			return nil
		}
	}
	if len(pending) > 0 {
		kinds := make([]string, len(pending))
		i := 0
		for gk := range pending {
			kinds[i] = gk.Kind
			i++
		}
		sort.Strings(kinds)
		if len(kinds) == 1 {
			return fmt.Errorf(
				"timed out while waiting for CRD '%s' to be established",
				kinds[0],
			)
		} else {
			return fmt.Errorf(
				"timed out while waiting for CRDs %s to be establised",
				logging.All(kinds),
			)
		}
	}
	return nil
}

func (a *Applier) applyObjects(ctx context.Context, objects []*unstructured.Unstructured) error {
	for _, object := range objects {
		err := a.applyObject(ctx, object)
		if err != nil {
			return err
		}
	}
	return nil
}

func (a *Applier) applyObject(ctx context.Context, object *unstructured.Unstructured) error {
	// Create a copy of the object so that we don't alter the original:
	copy, err := a.copyObject(object)
	if err != nil {
		a.fireError(ApplierCreateError, object, err)
		return err
	}

	// Add the labels:
	labels := copy.GetLabels()
	if labels == nil {
		labels = map[string]string{}
	}
	maps.Copy(labels, a.labels)
	copy.SetLabels(labels)

	// The object may have a status, but the create API ignores it, so we need to extract it and
	// apply it separately after the object has been created.
	status, ok := copy.Object["status"]
	if ok {
		delete(copy.Object, "status")
	}

	// Create the object:
	err = a.createObject(ctx, copy)
	if err != nil {
		return err
	}

	// Update the status:
	if status != nil {
		key := clnt.ObjectKeyFromObject(copy)
		err = retry.RetryOnConflict(retry.DefaultBackoff, func() error {
			err := a.client.Get(ctx, key, copy)
			if err != nil {
				a.fireError(ApplierStatusError, object, err)
				return err
			}
			copy.Object["status"] = status
			return a.client.Status().Update(ctx, copy)
		})
		if err != nil {
			a.fireError(ApplierStatusError, object, err)
			return err
		}
		a.fireInfo(ApplierStatusUpdated, object)
	}

	return nil
}

func (a *Applier) createObject(ctx context.Context, object *unstructured.Unstructured) error {
	// We may need to try the creation multiple times, because the kind of the object may
	// correspond to a CRD that hasn't been created yet. This function does the basic object
	// creation, without that logic, so that we can reuse it.
	createObject := func() error {
		err := a.client.Create(ctx, object)
		if err == nil {
			a.fireInfo(ApplierObjectCreated, object)
			return nil
		}
		if apierrors.IsAlreadyExists(err) {
			a.fireInfo(ApplierObjectExist, object)
			return nil
		}
		return err
	}

	// This function checks if the given error is the one returned by the server when the CRD
	// doesn't exist:
	isNoCRD := func(err error) bool {
		_, isNoKind := err.(*meta.NoKindMatchError)
		if isNoKind {
			return true
		}
		return apierrors.IsNotFound(err)
	}

	// If the creation fails because the CRD doesn't exist, chances are that it is because the
	// corresponding CRD is created by an operator that haven't created it yet. So we wait for
	// the CRD to be available.
	err := createObject()
	if err == nil {
		return nil
	}
	if !isNoCRD(err) {
		return err
	}
	a.fireInfo(ApplierWaitingCRD, object)
	err = a.waitCRDs(ctx, object.GroupVersionKind())
	if err != nil {
		return err
	}

	// Even after the CRD is established the API server will take some time to actually allow
	// creation of objects of that type. There is no good way to wait for that to happen, the
	// only alternative is to repeatedly try to create the object.
	config := backoff.NewExponentialBackOff()
	operation := func() error {
		err := createObject()
		if err == nil {
			return nil
		}
		if !isNoCRD(err) {
			return backoff.Permanent(err)
		}
		return err
	}
	return backoff.Retry(operation, backoff.WithContext(config, ctx))
}

func (a *Applier) deleteObjects(ctx context.Context, objects []*unstructured.Unstructured) error {
	var errs []error
	for _, object := range objects {
		err := a.deleteObject(ctx, object)
		if err != nil {
			errs = append(errs, err)
		}
	}
	if len(errs) > 0 {
		if len(errs) == 1 {
			return errs[0]
		} else {
			return fmt.Errorf("failed to delete %d objects", len(errs))
		}
	}
	return nil
}

func (a *Applier) deleteObject(ctx context.Context, object *unstructured.Unstructured) error {
	err := a.client.Delete(ctx, object)
	if apierrors.IsNotFound(err) {
		a.fireInfo(ApplierObjectNotExist, object)
		return nil
	}
	if err != nil {
		a.fireError(ApplierDeleteError, object, err)
		return err
	}
	a.fireInfo(ApplierObjectDeleted, object)
	return nil
}

func (a *Applier) deleteNamespaces(ctx context.Context, namespaces,
	objects []*unstructured.Unstructured) error {
	// To delete a namespace first we need to wait till all the objects inside it have been
	// completely deleted. That means that we need to find for each namespace the list of
	// objects that are inside it.
	index := map[string][]*unstructured.Unstructured{}
	for _, namespace := range namespaces {
		name := namespace.GetName()
		index[name] = nil
	}
	for _, object := range objects {
		namespace := object.GetNamespace()
		list, ok := index[namespace]
		if ok {
			index[namespace] = append(list, object)
		}
	}

	// Now we can proceed to wait for the objects to be completely deleted and delete the
	// namespaces themselves.
	for _, namespace := range namespaces {
		name := namespace.GetName()
		list := index[name]
		err := a.deleteNamespace(ctx, namespace, list)
		if err != nil {
			return err
		}
	}

	return nil
}

func (a *Applier) deleteNamespace(ctx context.Context, namespace *unstructured.Unstructured,
	objects []*unstructured.Unstructured) error {
	for _, object := range objects {
		err := a.waitDisappear(ctx, object)
		if err != nil {
			return err
		}
	}
	return a.deleteObject(ctx, namespace)
}

func (a *Applier) deleteCRDs(ctx context.Context, crds []*unstructured.Unstructured) error {
	// It would probably be better to wait till there are no objects of these types before
	// deleting them, but this is an operation that is rarely used, and usually only in
	// development environments, so it is not worth the complication at the moment.
	return a.deleteObjects(ctx, crds)
}

func (a *Applier) waitDisappear(ctx context.Context, object *unstructured.Unstructured) error {
	// Retrieve the current representation of the object to check if it has already disappeared:
	current := &unstructured.Unstructured{}
	current.SetGroupVersionKind(object.GroupVersionKind())
	key := clnt.ObjectKeyFromObject(object)
	err := a.client.Get(ctx, key, current)
	if apierrors.IsNotFound(err) {
		return nil
	}
	if err != nil {
		return err
	}

	// If the object hasn't disappeared yet then we need to wait till we receive the delete
	// event. But if the object has finalizers the object will not disappear inmediately after
	// receiving that event. In that case the API server will send a second delete event when
	// the last finalizer is removed. So each time we need to explicitly try to retrieve the
	// object to check if it has really disappeared.
	a.fireInfo(ApplierWaitingDisappear, object)
	list := &unstructured.UnstructuredList{}
	list.SetGroupVersionKind(current.GroupVersionKind())
	watch, err := a.client.Watch(
		ctx,
		list,
		clnt.InNamespace(current.GetNamespace()),
		clnt.MatchingFields{
			"metadata.name": current.GetName(),
		},
		&clnt.ListOptions{
			Raw: &metav1.ListOptions{
				ResourceVersion: current.GetResourceVersion(),
			},
		},
	)
	if err != nil {
		return err
	}
	defer watch.Stop()
	for event := range watch.ResultChan() {
		if event.Type != apiwatch.Deleted {
			continue
		}
		err = a.client.Get(ctx, key, current)
		if apierrors.IsNotFound(err) {
			return nil
		}
		if err != nil {
			return err
		}
	}
	return fmt.Errorf(
		"timed out while waiting for object '%s/%s' of kind '%s' to disappear",
		current.GetNamespace(), current.GetName(), current.GetKind(),
	)
}

func (a *Applier) renderObjects(ctx context.Context, data any,
	template string) (results []*unstructured.Unstructured, err error) {
	buffer := &bytes.Buffer{}
	err = a.engine.Execute(buffer, template, data)
	if err != nil {
		return
	}
	results, err = a.decodeObjects(buffer)
	if err != nil {
		err = fmt.Errorf(
			"failed to decode YAML generated from template '%s': %v",
			template, err,
		)
		return
	}
	return
}

func (a *Applier) decodeObjects(reader io.Reader) (results []*unstructured.Unstructured, err error) {
	var objects []map[string]any
	decoder := yaml.NewDecoder(reader)
	for {
		var object map[string]any
		err = decoder.Decode(&object)
		if errors.Is(err, io.EOF) {
			err = nil
			break
		}
		if err != nil {
			return
		}
		objects = append(objects, object)
	}
	results = make([]*unstructured.Unstructured, len(objects))
	for i, object := range objects {
		results[i] = &unstructured.Unstructured{
			Object: object,
		}
	}
	return
}

func (a *Applier) copyObject(object *unstructured.Unstructured) (result *unstructured.Unstructured,
	err error) {
	if object == nil {
		return
	}
	data, err := yaml.Marshal(object.Object)
	if err != nil {
		return
	}
	result = &unstructured.Unstructured{}
	err = yaml.Unmarshal(data, &result.Object)
	return
}

func (a *Applier) fireInfo(typ ApplierEventType, object *unstructured.Unstructured) {
	a.fireEvent(&ApplierEvent{
		Type:   typ,
		Object: object,
	})
}

func (a *Applier) fireError(typ ApplierEventType, object *unstructured.Unstructured,
	err error) {
	a.fireEvent(&ApplierEvent{
		Type:   typ,
		Object: object,
		Error:  err,
	})
}

func (a *Applier) fireEvent(event *ApplierEvent) {
	logger := a.logger.V(2)
	if logger.Enabled() {
		gvk := event.Object.GroupVersionKind()
		fields := []any{
			"group", gvk.Group,
			"version", gvk.Version,
			"kind", gvk.Kind,
			"namespace", event.Object.GetNamespace(),
			"name", event.Object.GetName(),
		}
		switch event.Type {
		case ApplierObjectCreated:
			logger.Info("Object created", fields...)
		case ApplierObjectExist:
			logger.Info("Object exists", fields...)
		case ApplierCreateError:
			logger.Error(event.Error, "Object error", fields...)
		case ApplierStatusUpdated:
			logger.Info("Status updated", fields...)
		case ApplierStatusError:
			logger.Info("Status error", fields...)
		case ApplierObjectDeleted:
			logger.Info("Object deleted", fields...)
		case ApplierWaitingCRD:
			logger.Info("Waiting for CRD", fields...)
		default:
			logger.Info("Event", fields...)
		}
	}
	for _, listener := range a.listeners {
		listener(event)
	}
}
