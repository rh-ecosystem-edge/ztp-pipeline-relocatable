/*
Copyright 2023 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
*/

package internal

import (
	"errors"
	"fmt"
	"io"
	"os"
	"sync"

	"github.com/go-logr/logr"
	"github.com/spf13/pflag"
	"golang.org/x/term"

	clnt "sigs.k8s.io/controller-runtime/pkg/client"
)

// ConsoleBuilder contains the data and logic needed to create an instance of the console. Don't
// create instances of this directly, use the NewConsole function instead.
type ConsoleBuilder struct {
	logger logr.Logger
	color  bool
	mute   bool
	out    io.Writer
	err    io.Writer
}

// Console knows how to write messages to the terminal. Don't create instances of this directly, use
// the NewConsole function instead.
type Console struct {
	logger   logr.Logger
	lock     *sync.Mutex
	mute     bool
	prefixes consolePrefixes
	out      io.Writer
	err      io.Writer
}

// NewConsole creates a builder that can then be used to configure and create a console.
func NewConsole() *ConsoleBuilder {
	return &ConsoleBuilder{
		color: true,
	}
}

// SetLogger sets the logger that the console will use to write messages to the log. This is
// mandatory.
func (b *ConsoleBuilder) SetLogger(value logr.Logger) *ConsoleBuilder {
	b.logger = value
	return b
}

// SetColor enables or disables use of color in the console. By default color is enabled if the
// console is a terminal and disabled otherwise.
func (b *ConsoleBuilder) SetColor(value bool) *ConsoleBuilder {
	b.color = value
	return b
}

// SetMute sets or clears the flag that indicates if the console should not write to its outpout and
// error streams. This is optional and by default the console does write to those streams. But in
// situations where the console and the logger write to the same streams it may be convenient to
// mute the console so it doesn't interfere with the JSON text written by the logger.
//
// Note that this setting doesn't affect how the log is written, in particular it doesn't affect the
// log messages generated by the console itself.
func (b *ConsoleBuilder) SetMute(value bool) *ConsoleBuilder {
	b.mute = value
	return b
}

// SetOut sets the standard output stream. This is mandatory, but will be ignored if the console is
// muted.
func (b *ConsoleBuilder) SetOut(value io.Writer) *ConsoleBuilder {
	b.out = value
	return b
}

// SetErr sets the standard error stream. This is mandatory, but will be ignored if the console is
// muted.
func (b *ConsoleBuilder) SetErr(value io.Writer) *ConsoleBuilder {
	b.err = value
	return b
}

// SetFlags sets the command line flags that that indicate how to configure the console. This is
// optional.
func (b *ConsoleBuilder) SetFlags(flags *pflag.FlagSet) *ConsoleBuilder {
	if flags.Changed(consoleColorFlag) {
		value, err := flags.GetBool(consoleColorFlag)
		if err == nil {
			b.SetColor(value)
		}
	}
	if flags.Changed(consoleMuteFlag) {
		value, err := flags.GetBool(consoleMuteFlag)
		if err == nil {
			b.SetMute(value)
		}
	}
	return b
}

// Build uses the data stored in the buider to create a new instance of the console.
func (b *ConsoleBuilder) Build() (result *Console, err error) {
	// Check parameters:
	if b.logger.GetSink() == nil {
		err = errors.New("logger is mandatory")
		return
	}
	if b.out == nil {
		err = errors.New("standard output stream is mandatory")
		return
	}
	if b.err == nil {
		err = errors.New("standard error stream is mandatory")
		return
	}

	// Check if the ouptput is a terminal:
	terminal := b.isTerminal(b.out) && b.isTerminal(b.err)

	// Select the color prefixes:
	prefixes := consoleMonoPrefixes
	if b.color && terminal {
		prefixes = consoleColorPrefixes
	}

	// Create and populate the object:
	result = &Console{
		logger:   b.logger,
		lock:     &sync.Mutex{},
		mute:     b.mute,
		prefixes: prefixes,
		out:      b.out,
		err:      b.err,
	}
	return
}

func (c *ConsoleBuilder) isTerminal(w io.Writer) bool {
	file, ok := w.(*os.File)
	if !ok {
		return false
	}
	return term.IsTerminal(int(file.Fd()))
}

// Info writes an informative message to the console.
func (c *Console) Info(format string, args ...any) {
	c.lock.Lock()
	defer c.lock.Unlock()
	text := fmt.Sprintf(format, c.replaceArgs(args)...)
	if !c.mute {
		fmt.Fprintf(c.out, "%s%s\n", c.prefixes.info, text)
	}
	c.logger.Info("Console info", "text", text)
}

// Wanr writes an warning message to the console.
func (c *Console) Warn(format string, args ...any) {
	c.lock.Lock()
	defer c.lock.Unlock()
	text := fmt.Sprintf(format, c.replaceArgs(args)...)
	if !c.mute {
		fmt.Fprintf(c.out, "%s%s\n", c.prefixes.warn, text)
	}
	c.logger.Info("Console warn", "text", text)
}

// Info writes an error message to the console.
func (c *Console) Error(format string, args ...any) {
	c.lock.Lock()
	defer c.lock.Unlock()
	text := fmt.Sprintf(format, c.replaceArgs(args)...)
	if !c.mute {
		fmt.Fprintf(c.err, "%s%s\n", c.prefixes.error, text)
	}
	c.logger.Info("Console error", "text", text)
}

func (c *Console) replaceArgs(args []any) []any {
	result := make([]any, len(args))
	for i, arg := range args {
		result[i] = c.replaceArg(arg)
	}
	return result
}

func (c *Console) replaceArg(arg any) any {
	switch value := arg.(type) {
	case clnt.Object:
		namespace := value.GetNamespace()
		name := value.GetName()
		if namespace != "" {
			return fmt.Sprintf("%s/%s", namespace, name)
		} else {
			return name
		}
	default:
		return value
	}
}

// consolePrefixes stores the prefixes used for messages.
type consolePrefixes struct {
	info  string
	warn  string
	error string
}

// consoleColorPrefixes contains the prefixes that use ANSI sequences to set colors when the output
// is a terminal that supports color.
var consoleColorPrefixes = consolePrefixes{
	info:  "\033[32;1mI:\033[0m ",
	warn:  "\033[33;1mW:\033[0m ",
	error: "\033[31;1mE:\033[0m ",
}

// consoleMonoPrefixes contains the monochrome prefixes that are used when the output isn't a
// terminal or when the terminal doesn't support color.
var consoleMonoPrefixes = consolePrefixes{
	info:  "I: ",
	warn:  "W: ",
	error: "E: ",
}
